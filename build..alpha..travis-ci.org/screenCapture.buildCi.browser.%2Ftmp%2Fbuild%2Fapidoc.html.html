<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/gcanti/tcomb">tcomb (v3.2.20)</a>
</h1>
<h4>Type checking and DDD for JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb">module tcomb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.tcomb">
            function <span class="apidocSignatureSpan"></span>tcomb
            <span class="apidocSignatureSpan">(guard, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Any">
            function <span class="apidocSignatureSpan">tcomb.</span>Any
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Arr">
            function <span class="apidocSignatureSpan">tcomb.</span>Arr
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Array">
            function <span class="apidocSignatureSpan">tcomb.</span>Array
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Bool">
            function <span class="apidocSignatureSpan">tcomb.</span>Bool
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Boolean">
            function <span class="apidocSignatureSpan">tcomb.</span>Boolean
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Dat">
            function <span class="apidocSignatureSpan">tcomb.</span>Dat
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Date">
            function <span class="apidocSignatureSpan">tcomb.</span>Date
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Err">
            function <span class="apidocSignatureSpan">tcomb.</span>Err
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Error">
            function <span class="apidocSignatureSpan">tcomb.</span>Error
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Func">
            function <span class="apidocSignatureSpan">tcomb.</span>Func
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Function">
            function <span class="apidocSignatureSpan">tcomb.</span>Function
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Integer">
            function <span class="apidocSignatureSpan">tcomb.</span>Integer
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.IntegerT">
            function <span class="apidocSignatureSpan">tcomb.</span>IntegerT
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Nil">
            function <span class="apidocSignatureSpan">tcomb.</span>Nil
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Num">
            function <span class="apidocSignatureSpan">tcomb.</span>Num
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Number">
            function <span class="apidocSignatureSpan">tcomb.</span>Number
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Obj">
            function <span class="apidocSignatureSpan">tcomb.</span>Obj
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Object">
            function <span class="apidocSignatureSpan">tcomb.</span>Object
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Re">
            function <span class="apidocSignatureSpan">tcomb.</span>Re
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.RegExp">
            function <span class="apidocSignatureSpan">tcomb.</span>RegExp
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Str">
            function <span class="apidocSignatureSpan">tcomb.</span>Str
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.String">
            function <span class="apidocSignatureSpan">tcomb.</span>String
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Type">
            function <span class="apidocSignatureSpan">tcomb.</span>Type
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.TypeT">
            function <span class="apidocSignatureSpan">tcomb.</span>TypeT
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert">
            function <span class="apidocSignatureSpan">tcomb.</span>assert
            <span class="apidocSignatureSpan">(guard, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.declare">
            function <span class="apidocSignatureSpan">tcomb.</span>declare
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.dict">
            function <span class="apidocSignatureSpan">tcomb.</span>dict
            <span class="apidocSignatureSpan">(domain, codomain, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.enums">
            function <span class="apidocSignatureSpan">tcomb.</span>enums
            <span class="apidocSignatureSpan">(map, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.fail">
            function <span class="apidocSignatureSpan">tcomb.</span>fail
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.func">
            function <span class="apidocSignatureSpan">tcomb.</span>func
            <span class="apidocSignatureSpan">(domain, codomain, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.getTypeName">
            function <span class="apidocSignatureSpan">tcomb.</span>getTypeName
            <span class="apidocSignatureSpan">(ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.inter">
            function <span class="apidocSignatureSpan">tcomb.</span>inter
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.interface">
            function <span class="apidocSignatureSpan">tcomb.</span>interface
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.intersection">
            function <span class="apidocSignatureSpan">tcomb.</span>intersection
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.irreducible">
            function <span class="apidocSignatureSpan">tcomb.</span>irreducible
            <span class="apidocSignatureSpan">(name, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.is">
            function <span class="apidocSignatureSpan">tcomb.</span>is
            <span class="apidocSignatureSpan">(x, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.isType">
            function <span class="apidocSignatureSpan">tcomb.</span>isType
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.list">
            function <span class="apidocSignatureSpan">tcomb.</span>list
            <span class="apidocSignatureSpan">(type, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.match">
            function <span class="apidocSignatureSpan">tcomb.</span>match
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.maybe">
            function <span class="apidocSignatureSpan">tcomb.</span>maybe
            <span class="apidocSignatureSpan">(type, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.mixin">
            function <span class="apidocSignatureSpan">tcomb.</span>mixin
            <span class="apidocSignatureSpan">(target, source, overwrite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.refinement">
            function <span class="apidocSignatureSpan">tcomb.</span>refinement
            <span class="apidocSignatureSpan">(type, predicate, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.stringify">
            function <span class="apidocSignatureSpan">tcomb.</span>stringify
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.struct">
            function <span class="apidocSignatureSpan">tcomb.</span>struct
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.subtype">
            function <span class="apidocSignatureSpan">tcomb.</span>subtype
            <span class="apidocSignatureSpan">(type, predicate, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.toString">
            function <span class="apidocSignatureSpan">tcomb.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.tuple">
            function <span class="apidocSignatureSpan">tcomb.</span>tuple
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.union">
            function <span class="apidocSignatureSpan">tcomb.</span>union
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.update">
            function <span class="apidocSignatureSpan">tcomb.</span>update
            <span class="apidocSignatureSpan">(instance, patch)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Any.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Array.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Boolean.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Date.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Error.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Function.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Integer.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Nil.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Number.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Object.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>RegExp.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>String.meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.</span>Type.meta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Any">module tcomb.Any</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Any.Any">
            function <span class="apidocSignatureSpan">tcomb.</span>Any
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Any.is">
            function <span class="apidocSignatureSpan">tcomb.Any.</span>is
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Any.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Any.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Any.meta">module tcomb.Any.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Any.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Any.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Any.meta.</span>predicate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Any.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Any.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Array">module tcomb.Array</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Array.Array">
            function <span class="apidocSignatureSpan">tcomb.</span>Array
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Array.is">
            function <span class="apidocSignatureSpan">tcomb.Array.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Array.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Array.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Array.meta">module tcomb.Array.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Array.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Array.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Array.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Array.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Array.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Boolean">module tcomb.Boolean</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Boolean.Boolean">
            function <span class="apidocSignatureSpan">tcomb.</span>Boolean
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Boolean.is">
            function <span class="apidocSignatureSpan">tcomb.Boolean.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Boolean.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Boolean.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Boolean.meta">module tcomb.Boolean.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Boolean.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Boolean.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Boolean.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Boolean.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Boolean.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Date">module tcomb.Date</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Date.Date">
            function <span class="apidocSignatureSpan">tcomb.</span>Date
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Date.is">
            function <span class="apidocSignatureSpan">tcomb.Date.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Date.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Date.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Date.meta">module tcomb.Date.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Date.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Date.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Date.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Date.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Date.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Error">module tcomb.Error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Error.Error">
            function <span class="apidocSignatureSpan">tcomb.</span>Error
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Error.is">
            function <span class="apidocSignatureSpan">tcomb.Error.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Error.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Error.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Error.meta">module tcomb.Error.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Error.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Error.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Error.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Error.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Error.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Function">module tcomb.Function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Function.Function">
            function <span class="apidocSignatureSpan">tcomb.</span>Function
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Function.is">
            function <span class="apidocSignatureSpan">tcomb.Function.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Function.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Function.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Function.meta">module tcomb.Function.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Function.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Function.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Function.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Function.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Function.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Integer">module tcomb.Integer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Integer.Integer">
            function <span class="apidocSignatureSpan">tcomb.</span>Integer
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Integer.is">
            function <span class="apidocSignatureSpan">tcomb.Integer.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Integer.update">
            function <span class="apidocSignatureSpan">tcomb.Integer.</span>update
            <span class="apidocSignatureSpan">(instance, patch)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Integer.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Integer.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Integer.meta">module tcomb.Integer.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Integer.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Integer.meta.type">
            function <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>type
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Nil">module tcomb.Nil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Nil.Nil">
            function <span class="apidocSignatureSpan">tcomb.</span>Nil
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Nil.is">
            function <span class="apidocSignatureSpan">tcomb.Nil.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Nil.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Nil.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Nil.meta">module tcomb.Nil.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Nil.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Nil.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Nil.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Nil.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Nil.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Number">module tcomb.Number</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Number.Number">
            function <span class="apidocSignatureSpan">tcomb.</span>Number
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Number.is">
            function <span class="apidocSignatureSpan">tcomb.Number.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Number.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Number.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Number.meta">module tcomb.Number.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Number.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Number.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Number.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Number.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Number.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Object">module tcomb.Object</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Object.Object">
            function <span class="apidocSignatureSpan">tcomb.</span>Object
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Object.is">
            function <span class="apidocSignatureSpan">tcomb.Object.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Object.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Object.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Object.meta">module tcomb.Object.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Object.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Object.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Object.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Object.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Object.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.RegExp">module tcomb.RegExp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.RegExp.RegExp">
            function <span class="apidocSignatureSpan">tcomb.</span>RegExp
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.RegExp.is">
            function <span class="apidocSignatureSpan">tcomb.RegExp.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.RegExp.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.RegExp.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.RegExp.meta">module tcomb.RegExp.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.RegExp.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.RegExp.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.RegExp.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.RegExp.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.RegExp.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.String">module tcomb.String</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.String.String">
            function <span class="apidocSignatureSpan">tcomb.</span>String
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.String.is">
            function <span class="apidocSignatureSpan">tcomb.String.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.String.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.String.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.String.meta">module tcomb.String.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.String.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.String.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.String.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.String.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.String.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Type">module tcomb.Type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Type.Type">
            function <span class="apidocSignatureSpan">tcomb.</span>Type
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Type.is">
            function <span class="apidocSignatureSpan">tcomb.Type.</span>is
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">tcomb.Type.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Type.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.Type.meta">module tcomb.Type.meta</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.Type.meta.</span>identity</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.Type.meta.predicate">
            function <span class="apidocSignatureSpan">tcomb.Type.meta.</span>predicate
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Type.meta.</span>kind</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">tcomb.Type.meta.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.assert">module tcomb.assert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.assert">
            function <span class="apidocSignatureSpan">tcomb.</span>assert
            <span class="apidocSignatureSpan">(guard, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Any">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Any
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Arr">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Arr
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Array">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Array
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Bool">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Bool
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Boolean">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Boolean
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Dat">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Dat
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Date">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Date
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Err">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Err
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Error">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Error
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Func">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Func
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Function">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Function
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Integer">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Integer
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.IntegerT">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>IntegerT
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Nil">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Nil
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Num">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Num
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Number">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Number
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Obj">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Obj
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Object">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Object
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Re">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Re
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.RegExp">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>RegExp
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Str">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Str
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.String">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>String
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.Type">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>Type
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.TypeT">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>TypeT
            <span class="apidocSignatureSpan">(value, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.declare">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>declare
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.dict">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>dict
            <span class="apidocSignatureSpan">(domain, codomain, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.enums">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>enums
            <span class="apidocSignatureSpan">(map, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.fail">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>fail
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.func">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>func
            <span class="apidocSignatureSpan">(domain, codomain, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.getTypeName">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>getTypeName
            <span class="apidocSignatureSpan">(ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.inter">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>inter
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.interface">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>interface
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.intersection">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>intersection
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.irreducible">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>irreducible
            <span class="apidocSignatureSpan">(name, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.is">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>is
            <span class="apidocSignatureSpan">(x, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.isType">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>isType
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.list">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>list
            <span class="apidocSignatureSpan">(type, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.match">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>match
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.maybe">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>maybe
            <span class="apidocSignatureSpan">(type, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.mixin">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>mixin
            <span class="apidocSignatureSpan">(target, source, overwrite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.refinement">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>refinement
            <span class="apidocSignatureSpan">(type, predicate, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.stringify">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>stringify
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.struct">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>struct
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.subtype">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>subtype
            <span class="apidocSignatureSpan">(type, predicate, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.tuple">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>tuple
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.union">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>union
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.assert.update">
            function <span class="apidocSignatureSpan">tcomb.assert.</span>update
            <span class="apidocSignatureSpan">(instance, patch)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.dict">module tcomb.dict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.dict.dict">
            function <span class="apidocSignatureSpan">tcomb.</span>dict
            <span class="apidocSignatureSpan">(domain, codomain, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.dict.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.dict.</span>getDefaultName
            <span class="apidocSignatureSpan">(domain, codomain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.enums">module tcomb.enums</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.enums.enums">
            function <span class="apidocSignatureSpan">tcomb.</span>enums
            <span class="apidocSignatureSpan">(map, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.enums.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.enums.</span>getDefaultName
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.enums.of">
            function <span class="apidocSignatureSpan">tcomb.enums.</span>of
            <span class="apidocSignatureSpan">(keys, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.func">module tcomb.func</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.func.func">
            function <span class="apidocSignatureSpan">tcomb.</span>func
            <span class="apidocSignatureSpan">(domain, codomain, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.func.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.func.</span>getDefaultName
            <span class="apidocSignatureSpan">(domain, codomain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.func.getOptionalArgumentsIndex">
            function <span class="apidocSignatureSpan">tcomb.func.</span>getOptionalArgumentsIndex
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.inter">module tcomb.inter</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.inter.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.inter.inter">
            function <span class="apidocSignatureSpan">tcomb.</span>inter
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.inter.extend">
            function <span class="apidocSignatureSpan">tcomb.inter.</span>extend
            <span class="apidocSignatureSpan">(mixins, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.inter.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.inter.</span>getDefaultName
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.inter.getOptions">
            function <span class="apidocSignatureSpan">tcomb.inter.</span>getOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.intersection">module tcomb.intersection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.intersection.intersection">
            function <span class="apidocSignatureSpan">tcomb.</span>intersection
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.intersection.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.intersection.</span>getDefaultName
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.list">module tcomb.list</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.list.list">
            function <span class="apidocSignatureSpan">tcomb.</span>list
            <span class="apidocSignatureSpan">(type, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.list.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.list.</span>getDefaultName
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.maybe">module tcomb.maybe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.maybe.maybe">
            function <span class="apidocSignatureSpan">tcomb.</span>maybe
            <span class="apidocSignatureSpan">(type, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.maybe.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.maybe.</span>getDefaultName
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.refinement">module tcomb.refinement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.refinement.refinement">
            function <span class="apidocSignatureSpan">tcomb.</span>refinement
            <span class="apidocSignatureSpan">(type, predicate, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.refinement.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.refinement.</span>getDefaultName
            <span class="apidocSignatureSpan">(type, predicate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.struct">module tcomb.struct</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">tcomb.struct.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.struct.struct">
            function <span class="apidocSignatureSpan">tcomb.</span>struct
            <span class="apidocSignatureSpan">(props, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.struct.extend">
            function <span class="apidocSignatureSpan">tcomb.struct.</span>extend
            <span class="apidocSignatureSpan">(mixins, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.struct.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.struct.</span>getDefaultName
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.struct.getOptions">
            function <span class="apidocSignatureSpan">tcomb.struct.</span>getOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.tuple">module tcomb.tuple</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.tuple.tuple">
            function <span class="apidocSignatureSpan">tcomb.</span>tuple
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.tuple.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.tuple.</span>getDefaultName
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.tcomb.union">module tcomb.union</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.union.union">
            function <span class="apidocSignatureSpan">tcomb.</span>union
            <span class="apidocSignatureSpan">(types, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.tcomb.union.getDefaultName">
            function <span class="apidocSignatureSpan">tcomb.union.</span>getDefaultName
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb" id="apidoc.module.tcomb">module tcomb</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.tcomb" id="apidoc.element.tcomb.tcomb">
        function <span class="apidocSignatureSpan"></span>tcomb
        <span class="apidocSignatureSpan">(guard, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assert(guard, message) {
  if (guard !== true) {
    if (isFunction(message)) { // handle lazy messages
      message = message();
    }
    else if (isNil(message)) { // use a default message
      message = 'Assert failed (turn on "Pause on exceptions" in your Source panel)';
    }
    assert.fail(message);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Any" id="apidoc.element.tcomb.Any">
        function <span class="apidocSignatureSpan">tcomb.</span>Any
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Arr" id="apidoc.element.tcomb.Arr">
        function <span class="apidocSignatureSpan">tcomb.</span>Arr
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Array" id="apidoc.element.tcomb.Array">
        function <span class="apidocSignatureSpan">tcomb.</span>Array
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Bool" id="apidoc.element.tcomb.Bool">
        function <span class="apidocSignatureSpan">tcomb.</span>Bool
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Boolean" id="apidoc.element.tcomb.Boolean">
        function <span class="apidocSignatureSpan">tcomb.</span>Boolean
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Dat" id="apidoc.element.tcomb.Dat">
        function <span class="apidocSignatureSpan">tcomb.</span>Dat
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Date" id="apidoc.element.tcomb.Date">
        function <span class="apidocSignatureSpan">tcomb.</span>Date
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Err" id="apidoc.element.tcomb.Err">
        function <span class="apidocSignatureSpan">tcomb.</span>Err
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Error" id="apidoc.element.tcomb.Error">
        function <span class="apidocSignatureSpan">tcomb.</span>Error
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Func" id="apidoc.element.tcomb.Func">
        function <span class="apidocSignatureSpan">tcomb.</span>Func
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Function" id="apidoc.element.tcomb.Function">
        function <span class="apidocSignatureSpan">tcomb.</span>Function
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Integer" id="apidoc.element.tcomb.Integer">
        function <span class="apidocSignatureSpan">tcomb.</span>Integer
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Refinement(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    if (identity) {
      forbidNewOperator(this, Refinement);
    }
    path = path || [displayName];
  }

  var x = create(type, value, path);

  if (process.env.NODE_ENV !== 'production') {
    assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.IntegerT" id="apidoc.element.tcomb.IntegerT">
        function <span class="apidocSignatureSpan">tcomb.</span>IntegerT
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Refinement(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    if (identity) {
      forbidNewOperator(this, Refinement);
    }
    path = path || [displayName];
  }

  var x = create(type, value, path);

  if (process.env.NODE_ENV !== 'production') {
    assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Nil" id="apidoc.element.tcomb.Nil">
        function <span class="apidocSignatureSpan">tcomb.</span>Nil
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Num" id="apidoc.element.tcomb.Num">
        function <span class="apidocSignatureSpan">tcomb.</span>Num
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Number" id="apidoc.element.tcomb.Number">
        function <span class="apidocSignatureSpan">tcomb.</span>Number
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

A type-checked function:

```js
import t from 'tcomb';

function sum(a, b) {
  t.<span class="apidocCodeKeywordSpan">Number</span>(a);
  t.Number(b);
  return a + b;
}

sum(1, 's'); // throws '[tcomb] Invalid value "s" supplied to Number'

// using babel-plugin-tcomb
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Obj" id="apidoc.element.tcomb.Obj">
        function <span class="apidocSignatureSpan">tcomb.</span>Obj
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Object" id="apidoc.element.tcomb.Object">
        function <span class="apidocSignatureSpan">tcomb.</span>Object
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Re" id="apidoc.element.tcomb.Re">
        function <span class="apidocSignatureSpan">tcomb.</span>Re
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.RegExp" id="apidoc.element.tcomb.RegExp">
        function <span class="apidocSignatureSpan">tcomb.</span>RegExp
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Str" id="apidoc.element.tcomb.Str">
        function <span class="apidocSignatureSpan">tcomb.</span>Str
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.String" id="apidoc.element.tcomb.String">
        function <span class="apidocSignatureSpan">tcomb.</span>String
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Type" id="apidoc.element.tcomb.Type">
        function <span class="apidocSignatureSpan">tcomb.</span>Type
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.TypeT" id="apidoc.element.tcomb.TypeT">
        function <span class="apidocSignatureSpan">tcomb.</span>TypeT
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert" id="apidoc.element.tcomb.assert">
        function <span class="apidocSignatureSpan">tcomb.</span>assert
        <span class="apidocSignatureSpan">(guard, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assert(guard, message) {
  if (guard !== true) {
    if (isFunction(message)) { // handle lazy messages
      message = message();
    }
    else if (isNil(message)) { // use a default message
      message = 'Assert failed (turn on "Pause on exceptions" in your Source panel)';
    }
    assert.fail(message);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.declare" id="apidoc.element.tcomb.declare">
        function <span class="apidocSignatureSpan">tcomb.</span>declare
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function declare(name) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string
)'; });
  }

  var type;

  function Declare(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      assert(!isNil(type), function () { return 'Type declared but not defined, don\'t forget to call .define on every declared
type'; });
      if (isUnion(type)) {
        assert(type.dispatch === Declare.dispatch, function () { return 'Please define the custom ' + name + '.dispatch function
 before calling ' + name + '.define()'; });
      }
    }
    return type(value, path);
  }

  Declare.define = function (spec) {
    if (process.env.NODE_ENV !== 'production') {
      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (
expected a type)'; });
      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
      assert(isNil(spec.meta.name) &amp;&amp; Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' +
assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
    }

    if (isUnion(spec) &amp;&amp; Declare.hasOwnProperty('dispatch')) {
      spec.dispatch = Declare.dispatch;
    }
    type = spec;
    mixin(Declare, type, true); // true because it overwrites Declare.displayName
    if (name) {
      type.displayName = Declare.displayName = name;
      Declare.meta.name = name;
    }
    Declare.meta.identity = type.meta.identity;
    Declare.prototype = type.prototype;
    return Declare;
  };

  Declare.displayName = name || ( getTypeName(Declare) + "$" + nextDeclareUniqueId++ );
  // in general I can't say if this type will be an identity, for safety setting to false
  Declare.meta = { identity: false };
  Declare.prototype = null;
  return Declare;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.dict" id="apidoc.element.tcomb.dict">
        function <span class="apidocSignatureSpan">tcomb.</span>dict
        <span class="apidocSignatureSpan">(domain, codomain, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dict(domain, codomain, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain
, codomain, [name]) combinator (expected a type)'; });
    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to
dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain,
codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainNameCache = getTypeName(domain);
  var codomainNameCache = getTypeName(codomain);
  var identity = isIdentity(domain) &amp;&amp; isIdentity(codomain);

  function Dict(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true
    for (var k in value) {
      if (value.hasOwnProperty(k)) {
        k = create(domain, k, ( process.env.NODE_ENV !== 'production' ? path.concat(domainNameCache) : null ));
        var actual = value[k];
        var instance = create(codomain, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + codomainNameCache
) : null ));
        idempotent = idempotent &amp;&amp; ( actual === instance );
        ret[k] = instance;
      }
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Dict.meta = {
    kind: 'dict',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: identity
  };

  Dict.displayName = displayName;

  Dict.is = function (x) {
    if (!isObject(x)) {
      return false;
    }
    for (var k in x) {
      if (x.hasOwnProperty(k)) {
        if (!is(k, domain) || !is(x[k], codomain)) {
          return false;
        }
      }
    }
    return true;
  };

  Dict.update = function (instance, patch) {
    return Dict(assert.update(instance, patch));
  };

  return Dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.enums" id="apidoc.element.tcomb.enums">
        function <span class="apidocSignatureSpan">tcomb.</span>enums
        <span class="apidocSignatureSpan">(map, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enums(map, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name])
combinator (expected a dictionary of String -&gt; String | Number)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(map);

  function Enums(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Enums);
      path = path || [displayName];
      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected one of ' + assert.stringify(Object.keys(map)) + ')'; });
    }

    return value;
  }

  Enums.meta = {
    kind: 'enums',
    map: map,
    name: name,
    identity: true
  };

  Enums.displayName = displayName;

  Enums.is = function (x) {
    return map.hasOwnProperty(x);
  };

  return Enums;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.fail" id="apidoc.element.tcomb.fail">
        function <span class="apidocSignatureSpan">tcomb.</span>fail
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fail(message) {
  throw new TypeError('[tcomb] ' + message);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
    }

    if (type.is(x) &amp;&amp; guard(x)) {
      return f(x);
    }
  }
  assert.<span class="apidocCodeKeywordSpan">fail</span>('Match error');
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.func" id="apidoc.element.tcomb.func">
        function <span class="apidocSignatureSpan">tcomb.</span>func
        <span class="apidocSignatureSpan">(domain, codomain, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function func(domain, codomain, name) {

  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions

  if (process.env.NODE_ENV !== 'production') {
    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied
 to func(domain, codomain, [name]) combinator (expected an array of types)'; });
    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied
 to func(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain,
codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainLength = domain.length;
  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);

  function FuncType(value, path) {

    if (!isInstrumented(value)) { // automatically instrument the function
      return FuncType.of(value);
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  FuncType.meta = {
    kind: 'func',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: true
  };

  FuncType.displayName = displayName;

  FuncType.is = function (x) {
    return isInstrumented(x) &amp;&amp;
      x.instrumentation.domain.length === domainLength &amp;&amp;
      x.instrumentation.domain.every(function (type, i) {
        return type === domain[i];
      }) &amp;&amp;
      x.instrumentation.codomain === codomain;
  };

  FuncType.of = function (f, curried) {

    if (process.env.NODE_ENV !== 'production') {
      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function
)'; });
      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + '
supplied to func.of ' + displayName + ' (expected a boolean)'; });
    }

    if (FuncType.is(f)) { // makes FuncType.of idempotent
      return f;
    }

    function fn() {
      var args = Array.prototype.slice.call(arguments);
      var argsLength = args.length;

      if (process.env.NODE_ENV !== 'production') {
        // type-check arguments
        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);
        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);
      }

      if (curried &amp;&amp; argsLength &lt; domainLength) {
        if (process.env.NODE_ENV !== 'production') {
          assert(argsLength &gt; 0, 'Invalid arguments.length = 0 for curried function ' + displayName);
        }
        var g = Function.prototype.bind.apply(f, [this].concat(args));
        var newDomain = func(domain.slice(argsLength), codomain);
        return newDomain.of(g, true);
      }
      else {
        return create(codomain, f.apply(this, args));
      }
    }

    fn.instrumentation = {
      domain: domain,
      codomain: codomain,
      f: f
    };

    fn.displayName = getFunctionName(f);

    return fn;

  };

  return FuncType;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.getTypeName" id="apidoc.element.tcomb.getTypeName">
        function <span class="apidocSignatureSpan">tcomb.</span>getTypeName
        <span class="apidocSignatureSpan">(ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTypeName(ctor) {
  if (isType(ctor)) {
    return ctor.displayName;
  }
  return getFunctionName(ctor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.inter" id="apidoc.element.tcomb.inter">
        function <span class="apidocSignatureSpan">tcomb.</span>inter
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inter(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to interface(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
  }

  var displayName = name || getDefaultInterfaceName(props);
  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);

  function Interface(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
      // strictness
      if (strict) {
        for (var k in value) {
          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
        }
      }
    }

    var idempotent = true;
    var ret = identity ? {} : assign({}, value);
    for (var prop in props) {
      var expected = props[prop];
      var actual = value[prop];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret[prop] = instance;
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;

  }

  Interface.meta = {
    kind: 'interface',
    props: props,
    name: name,
    identity: identity,
    strict: strict
  };

  Interface.displayName = displayName;

  Interface.is = function (x) {
    if (isNil(x)) {
      return false;
    }
    if (strict) {
      for (var k in x) {
        if (!props.hasOwnProperty(k)) {
          return false;
        }
      }
    }
    for (var prop in props) {
      if (!is(x[prop], props[prop])) {
        return false;
      }
    }
    return true;
  };

  Interface.update = function (instance, patch) {
    return Interface(assert.update(instance, patch));
  };

  Interface.extend = function (xs, name) {
    return extendInterface([Interface].concat(xs), name);
  };

  return Interface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.interface" id="apidoc.element.tcomb.interface">
        function <span class="apidocSignatureSpan">tcomb.</span>interface
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inter(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to interface(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
  }

  var displayName = name || getDefaultInterfaceName(props);
  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);

  function Interface(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
      // strictness
      if (strict) {
        for (var k in value) {
          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
        }
      }
    }

    var idempotent = true;
    var ret = identity ? {} : assign({}, value);
    for (var prop in props) {
      var expected = props[prop];
      var actual = value[prop];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret[prop] = instance;
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;

  }

  Interface.meta = {
    kind: 'interface',
    props: props,
    name: name,
    identity: identity,
    strict: strict
  };

  Interface.displayName = displayName;

  Interface.is = function (x) {
    if (isNil(x)) {
      return false;
    }
    if (strict) {
      for (var k in x) {
        if (!props.hasOwnProperty(k)) {
          return false;
        }
      }
    }
    for (var prop in props) {
      if (!is(x[prop], props[prop])) {
        return false;
      }
    }
    return true;
  };

  Interface.update = function (instance, patch) {
    return Interface(assert.update(instance, patch));
  };

  Interface.extend = function (xs, name) {
    return extendInterface([Interface].concat(xs), name);
  };

  return Interface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.intersection" id="apidoc.element.tcomb.intersection">
        function <span class="apidocSignatureSpan">tcomb.</span>intersection
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersection(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction) &amp;&amp; types.length &gt;= 2, function () { return 'Invalid argument types ' + assert
.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection
(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Intersection(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Intersection);
      }
      path = path || [displayName];
      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join
('/'); });
    }

    return value;
  }

  Intersection.meta = {
    kind: 'intersection',
    types: types,
    name: name,
    identity: identity
  };

  Intersection.displayName = displayName;

  Intersection.is = function (x) {
    return types.every(function (type) {
      return is(x, type);
    });
  };

  Intersection.update = function (instance, patch) {
    return Intersection(assert.update(instance, patch));
  };

  return Intersection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.irreducible" id="apidoc.element.tcomb.irreducible">
        function <span class="apidocSignatureSpan">tcomb.</span>irreducible
        <span class="apidocSignatureSpan">(name, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function irreducible(name, predicate) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isString(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name
, predicate) (expected a string)'; });
    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name,
predicate) (expected a function)');
  }

  function Irreducible(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Irreducible);
      path = path || [name];
      assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  Irreducible.meta = {
    kind: 'irreducible',
    name: name,
    predicate: predicate,
    identity: true
  };

  Irreducible.displayName = name;

  Irreducible.is = predicate;

  return Irreducible;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.is" id="apidoc.element.tcomb.is">
        function <span class="apidocSignatureSpan">tcomb.</span>is
        <span class="apidocSignatureSpan">(x, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function is(x, type) {
  if (isType(type)) {
    return type.is(x);
  }
  return x instanceof type; // type should be a class constructor
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.isType" id="apidoc.element.tcomb.isType">
        function <span class="apidocSignatureSpan">tcomb.</span>isType
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isType(x) {
  return isFunction(x) &amp;&amp; isObject(x.meta);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.list" id="apidoc.element.tcomb.list">
        function <span class="apidocSignatureSpan">tcomb.</span>list
        <span class="apidocSignatureSpan">(type, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function list(type, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [
name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var typeNameCache = getTypeName(type);
  var identity = isIdentity(type); // the list is identity iif type is identity

  function List(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected an array of ' + typeNameCache + ')'; });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = []; // make a temporary copy, will be discarded if idempotent remains true
    for (var i = 0, len = value.length; i &lt; len; i++ ) {
      var actual = value[i];
      var instance = create(type, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null
 ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  List.meta = {
    kind: 'list',
    type: type,
    name: name,
    identity: identity
  };

  List.displayName = displayName;

  List.is = function (x) {
    return isArray(x) &amp;&amp; x.every(function (e) {
      return is(e, type);
    });
  };

  List.update = function (instance, patch) {
    return List(assert.update(instance, patch));
  };

  return List;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A type-checked class:

```js
const Person = t.struct({
  name: t.String,              // required string
  surname: t.maybe(t.String),  // optional string
  age: t.Integer,                // required integer
  tags: t.<span class="apidocCodeKeywordSpan">list</span>(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
Person.prototype.getFullName = function () {
  return `${this.name} ${this.surname}`;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.match" id="apidoc.element.tcomb.match">
        function <span class="apidocSignatureSpan">tcomb.</span>match
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(x) {
  var type, guard, f, count;
  for (var i = 1, len = arguments.length; i &lt; len; ) {
    type = arguments[i];
    guard = arguments[i + 1];
    f = arguments[i + 2];

    if (isFunction(f) &amp;&amp; !isType(f)) {
      i = i + 3;
    }
    else {
      f = guard;
      guard = Any.is;
      i = i + 2;
    }

    if (process.env.NODE_ENV !== 'production') {
      count = (count || 0) + 1;
      assert(isType(type), function () { return 'Invalid type in clause #' + count; });
      assert(isFunction(guard), function () { return 'Invalid guard in clause #' + count; });
      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
    }

    if (type.is(x) &amp;&amp; guard(x)) {
      return f(x);
    }
  }
  assert.fail('Match error');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.error(message);
};
```

**Pattern matching**

```js
const result = t.<span class="apidocCodeKeywordSpan">match</span>(1,
  t.String, () =&gt; 'a string',
  t.Number, () =&gt; 'a number'
);

console.log(result); // =&gt; 'a number'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.maybe" id="apidoc.element.tcomb.maybe">
        function <span class="apidocSignatureSpan">tcomb.</span>maybe
        <span class="apidocSignatureSpan">(type, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function maybe(type, name) {

  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil
    return type;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [
name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var identity = isIdentity(type);

  function Maybe(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Maybe);
      }
    }
    return Nil.is(value) ? value : create(type, value, path);
  }

  Maybe.meta = {
    kind: 'maybe',
    type: type,
    name: name,
    identity: identity
  };

  Maybe.displayName = displayName;

  Maybe.is = function (x) {
    return Nil.is(x) || is(x, type);
  };

  return Maybe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A type-checked class:

```js
const Person = t.struct({
name: t.String,              // required string
surname: t.<span class="apidocCodeKeywordSpan">maybe</span>(t.String),  // optional string
age: t.Integer,                // required integer
tags: t.list(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
Person.prototype.getFullName = function () {
return `${this.name} ${this.surname}`;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.mixin" id="apidoc.element.tcomb.mixin">
        function <span class="apidocSignatureSpan">tcomb.</span>mixin
        <span class="apidocSignatureSpan">(target, source, overwrite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mixin(target, source, overwrite) {
  if (isNil(source)) { return target; }
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      if (overwrite !== true) {
        if (process.env.NODE_ENV !== 'production') {
          assert(!target.hasOwnProperty(k) || target[k] === source[k], function () { return 'Invalid call to mixin(target, source
, [overwrite]): cannot overwrite property "' + k + '" of target object'; });
        }
      }
      target[k] = source[k];
    }
  }
  return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.refinement" id="apidoc.element.tcomb.refinement">
        function <span class="apidocSignatureSpan">tcomb.</span>refinement
        <span class="apidocSignatureSpan">(type, predicate, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refinement(type, predicate, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name
]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Refinement);
      }
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (process.env.NODE_ENV !== 'production') {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) &amp;&amp; predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return a + b;
}
```

A user defined type:

```js
const Integer = t.<span class="apidocCodeKeywordSpan">refinement</span>(t.Number, (n) =&gt; n % 1 === 0, 'Integer');
```

A type-checked class:

```js
const Person = t.struct({
name: t.String,              // required string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.stringify" id="apidoc.element.tcomb.stringify">
        function <span class="apidocSignatureSpan">tcomb.</span>stringify
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringify(x) {
  try { // handle "Converting circular structure to JSON" error
    return JSON.stringify(x, replacer, 2);
  }
  catch (e) {
    return String(x);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
return type(value, path);
  }

  Declare.define = function (spec) {
if (process.env.NODE_ENV !== 'production') {
  assert(isType(spec), function () { return 'Invalid argument type ' + assert.<span class="apidocCodeKeywordSpan">stringify
</span>(spec) +  ' supplied to define(type) (expected a type)'; });
  assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
  assert(isNil(spec.meta.name) &amp;&amp; Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument
 type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
}

if (isUnion(spec) &amp;&amp; Declare.hasOwnProperty('dispatch')) {
  spec.dispatch = Declare.dispatch;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.struct" id="apidoc.element.tcomb.struct">
        function <span class="apidocSignatureSpan">tcomb.</span>struct
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function struct(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;
  var defaultProps = options.defaultProps;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to struct(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
    assert(isObject(defaultProps), function () { return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied
 to struct(props, [options]) combinator (expected an object)'; });
  }

  var displayName = name || getDefaultName(props);

  function Struct(value, path) {

    if (Struct.is(value)) { // implements idempotency
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected an object)'; });
      // strictness
      if (strict) {
        for (k in value) {
          if (value.hasOwnProperty(k)) {
            assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
          }
        }
      }
    }

    if (!(this instanceof Struct)) { // `new` is optional
      return new Struct(value, path);
    }

    for (var k in props) {
      if (props.hasOwnProperty(k)) {
        var expected = props[k];
        var actual = value[k];
        // apply defaults
        if (actual === undefined) {
          actual = defaultProps[k];
        }
        this[k] = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + getTypeName(expected
)) : null ));
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(this);
    }

  }

  Struct.meta = {
    kind: 'struct',
    props: props,
    name: name,
    identity: false,
    strict: strict,
    defaultProps: defaultProps
  };

  Struct.displayName = displayName;

  Struct.is = function (x) {
    return x instanceof Struct;
  };

  Struct.update = function (instance, patch) {
    return new Struct(assert.update(instance, patch));
  };

  Struct.extend = function (xs, name) {
    return extendStruct([Struct].concat(xs), name);
  };

  return Struct;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
const Integer = t.refinement(t.Number, (n) =&gt; n % 1 === 0, 'Integer');
```

A type-checked class:

```js
const Person = t.<span class="apidocCodeKeywordSpan">struct</span>({
  name: t.String,              // required string
  surname: t.maybe(t.String),  // optional string
  age: t.Integer,                // required integer
  tags: t.list(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.subtype" id="apidoc.element.tcomb.subtype">
        function <span class="apidocSignatureSpan">tcomb.</span>subtype
        <span class="apidocSignatureSpan">(type, predicate, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refinement(type, predicate, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name
]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Refinement);
      }
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (process.env.NODE_ENV !== 'production') {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) &amp;&amp; predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.toString" id="apidoc.element.tcomb.toString">
        function <span class="apidocSignatureSpan">tcomb.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.tuple" id="apidoc.element.tcomb.tuple">
        function <span class="apidocSignatureSpan">tcomb.</span>tuple
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tuple(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + '
supplied to tuple(types, [name]) combinator (expected an array of types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Tuple(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value) &amp;&amp; value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + '
supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });
    }

    var idempotent = true;
    var ret = [];
    for (var i = 0, len = types.length; i &lt; len; i++) {
      var expected = types[i];
      var actual = value[i];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Tuple.meta = {
    kind: 'tuple',
    types: types,
    name: name,
    identity: identity
  };

  Tuple.displayName = displayName;

  Tuple.is = function (x) {
    return isArray(x) &amp;&amp;
      x.length === types.length &amp;&amp;
      types.every(function (type, i) {
        return is(x[i], type);
      });
  };

  Tuple.update = function (instance, patch) {
    return Tuple(assert.update(instance, patch));
  };

  return Tuple;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.union" id="apidoc.element.tcomb.union">
        function <span class="apidocSignatureSpan">tcomb.</span>union
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function union(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction) &amp;&amp; types.length &gt;= 2, function () { return 'Invalid argument types ' + assert
.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Union(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    var type = Union.dispatch(value);
    if (!type &amp;&amp; Union.is(value)) {
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Union);
      }
      path = path || [displayName];
      assert(isFunction(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
no constructor returned by dispatch)'; });
      path[path.length - 1] += '(' + getTypeName(type) + ')';
    }

    return create(type, value, path);
  }

  Union.meta = {
    kind: 'union',
    types: types,
    name: name,
    identity: identity
  };

  Union.displayName = displayName;

  Union.is = function (x) {
    return types.some(function (type) {
      return is(x, type);
    });
  };

  Union.dispatch = function (x) { // default dispatch implementation
    for (var i = 0, len = types.length; i &lt; len; i++ ) {
      var type = types[i];
      if (isUnion(type)) { // handle union of unions
        var t = type.dispatch(x);
        if (!isNil(t)) {
          return t;
        }
      }
      else if (is(x, type)) {
        return type;
      }
    }
  };

  Union.update = function (instance, patch) {
    return Union(assert.update(instance, patch));
  };

  return Union;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.update" id="apidoc.element.tcomb.update">
        function <span class="apidocSignatureSpan">tcomb.</span>update
        <span class="apidocSignatureSpan">(instance, patch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function update(instance, patch) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(patch), function () { return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update
(instance, patch): expected an object containing commands'; });
  }

  var value = instance;
  var isChanged = false;
  var newValue;
  for (var k in patch) {
    if (patch.hasOwnProperty(k)) {
      if (isCommand(k)) {
        newValue = getCommand(k)(patch[k], value);
        if (newValue !== instance) {
          isChanged = true;
          value = newValue;
        } else {
          value = instance;
        }
      }
      else {
        if (value === instance) {
          value = getShallowCopy(instance);
        }
        newValue = update(value[k], patch[k]);
        isChanged = isChanged || ( newValue !== value[k] );
        value[k] = newValue;
      }
    }
  }
  return isChanged ? value : instance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* interfaces

**Immutability and immutability helpers**

Instances are immutable using `Object.freeze`. This means you can use standard JavaScript objects and arrays. You don't have
 to change how you normally code. You can update an immutable instance with the provided `update(instance, spec)` function:

```js
const person2 = Person.<span class="apidocCodeKeywordSpan">update</span>(person, {
  name: { $set: 'Guido' }
});
```

where `spec` is an object containing *commands*. The following commands are compatible with the [Facebook Immutability Helpers](
http://facebook.github.io/react/docs/update.html):

* `$push`
...</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Any" id="apidoc.module.tcomb.Any">module tcomb.Any</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Any.Any" id="apidoc.element.tcomb.Any.Any">
        function <span class="apidocSignatureSpan">tcomb.</span>Any
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Any.is" id="apidoc.element.tcomb.Any.is">
        function <span class="apidocSignatureSpan">tcomb.Any.</span>is
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is = function () { return true; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Any.meta" id="apidoc.module.tcomb.Any.meta">module tcomb.Any.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Any.meta.predicate" id="apidoc.element.tcomb.Any.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Any.meta.</span>predicate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predicate = function () { return true; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Array" id="apidoc.module.tcomb.Array">module tcomb.Array</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Array.Array" id="apidoc.element.tcomb.Array.Array">
        function <span class="apidocSignatureSpan">tcomb.</span>Array
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Array.is" id="apidoc.element.tcomb.Array.is">
        function <span class="apidocSignatureSpan">tcomb.Array.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray(x) {
  return Array.isArray ? Array.isArray(x) : x instanceof Array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Array.meta" id="apidoc.module.tcomb.Array.meta">module tcomb.Array.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Array.meta.predicate" id="apidoc.element.tcomb.Array.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Array.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray(x) {
  return Array.isArray ? Array.isArray(x) : x instanceof Array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Boolean" id="apidoc.module.tcomb.Boolean">module tcomb.Boolean</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Boolean.Boolean" id="apidoc.element.tcomb.Boolean.Boolean">
        function <span class="apidocSignatureSpan">tcomb.</span>Boolean
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Boolean.is" id="apidoc.element.tcomb.Boolean.is">
        function <span class="apidocSignatureSpan">tcomb.Boolean.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBoolean(x) {
  return x === true || x === false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Boolean.meta" id="apidoc.module.tcomb.Boolean.meta">module tcomb.Boolean.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Boolean.meta.predicate" id="apidoc.element.tcomb.Boolean.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Boolean.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBoolean(x) {
  return x === true || x === false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Date" id="apidoc.module.tcomb.Date">module tcomb.Date</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Date.Date" id="apidoc.element.tcomb.Date.Date">
        function <span class="apidocSignatureSpan">tcomb.</span>Date
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Date.is" id="apidoc.element.tcomb.Date.is">
        function <span class="apidocSignatureSpan">tcomb.Date.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is = function (x) { return x instanceof Date; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Date.meta" id="apidoc.module.tcomb.Date.meta">module tcomb.Date.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Date.meta.predicate" id="apidoc.element.tcomb.Date.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Date.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predicate = function (x) { return x instanceof Date; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Error" id="apidoc.module.tcomb.Error">module tcomb.Error</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Error.Error" id="apidoc.element.tcomb.Error.Error">
        function <span class="apidocSignatureSpan">tcomb.</span>Error
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Error.is" id="apidoc.element.tcomb.Error.is">
        function <span class="apidocSignatureSpan">tcomb.Error.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is = function (x) { return x instanceof Error; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Error.meta" id="apidoc.module.tcomb.Error.meta">module tcomb.Error.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Error.meta.predicate" id="apidoc.element.tcomb.Error.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Error.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predicate = function (x) { return x instanceof Error; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Function" id="apidoc.module.tcomb.Function">module tcomb.Function</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Function.Function" id="apidoc.element.tcomb.Function.Function">
        function <span class="apidocSignatureSpan">tcomb.</span>Function
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Function.is" id="apidoc.element.tcomb.Function.is">
        function <span class="apidocSignatureSpan">tcomb.Function.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(x) {
  return typeof x === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Function.meta" id="apidoc.module.tcomb.Function.meta">module tcomb.Function.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Function.meta.predicate" id="apidoc.element.tcomb.Function.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Function.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(x) {
  return typeof x === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Integer" id="apidoc.module.tcomb.Integer">module tcomb.Integer</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Integer.Integer" id="apidoc.element.tcomb.Integer.Integer">
        function <span class="apidocSignatureSpan">tcomb.</span>Integer
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Refinement(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    if (identity) {
      forbidNewOperator(this, Refinement);
    }
    path = path || [displayName];
  }

  var x = create(type, value, path);

  if (process.env.NODE_ENV !== 'production') {
    assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Integer.is" id="apidoc.element.tcomb.Integer.is">
        function <span class="apidocSignatureSpan">tcomb.Integer.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is = function (x) {
  return is(x, type) &amp;&amp; predicate(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Integer.update" id="apidoc.element.tcomb.Integer.update">
        function <span class="apidocSignatureSpan">tcomb.Integer.</span>update
        <span class="apidocSignatureSpan">(instance, patch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (instance, patch) {
  return Refinement(assert.update(instance, patch));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* interfaces

**Immutability and immutability helpers**

Instances are immutable using `Object.freeze`. This means you can use standard JavaScript objects and arrays. You don't have
 to change how you normally code. You can update an immutable instance with the provided `update(instance, spec)` function:

```js
const person2 = Person.<span class="apidocCodeKeywordSpan">update</span>(person, {
  name: { $set: 'Guido' }
});
```

where `spec` is an object containing *commands*. The following commands are compatible with the [Facebook Immutability Helpers](
http://facebook.github.io/react/docs/update.html):

* `$push`
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Integer.meta" id="apidoc.module.tcomb.Integer.meta">module tcomb.Integer.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Integer.meta.predicate" id="apidoc.element.tcomb.Integer.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predicate = function (x) { return x % 1 === 0; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Integer.meta.type" id="apidoc.element.tcomb.Integer.meta.type">
        function <span class="apidocSignatureSpan">tcomb.Integer.meta.</span>type
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Nil" id="apidoc.module.tcomb.Nil">module tcomb.Nil</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Nil.Nil" id="apidoc.element.tcomb.Nil.Nil">
        function <span class="apidocSignatureSpan">tcomb.</span>Nil
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Nil.is" id="apidoc.element.tcomb.Nil.is">
        function <span class="apidocSignatureSpan">tcomb.Nil.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNil(x) {
  return x === null || x === void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Nil.meta" id="apidoc.module.tcomb.Nil.meta">module tcomb.Nil.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Nil.meta.predicate" id="apidoc.element.tcomb.Nil.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Nil.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNil(x) {
  return x === null || x === void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Number" id="apidoc.module.tcomb.Number">module tcomb.Number</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Number.Number" id="apidoc.element.tcomb.Number.Number">
        function <span class="apidocSignatureSpan">tcomb.</span>Number
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

A type-checked function:

```js
import t from 'tcomb';

function sum(a, b) {
  t.<span class="apidocCodeKeywordSpan">Number</span>(a);
  t.Number(b);
  return a + b;
}

sum(1, 's'); // throws '[tcomb] Invalid value "s" supplied to Number'

// using babel-plugin-tcomb
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Number.is" id="apidoc.element.tcomb.Number.is">
        function <span class="apidocSignatureSpan">tcomb.Number.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumber(x) {
  return typeof x === 'number' &amp;&amp; isFinite(x) &amp;&amp; !isNaN(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Number.meta" id="apidoc.module.tcomb.Number.meta">module tcomb.Number.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Number.meta.predicate" id="apidoc.element.tcomb.Number.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Number.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumber(x) {
  return typeof x === 'number' &amp;&amp; isFinite(x) &amp;&amp; !isNaN(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Object" id="apidoc.module.tcomb.Object">module tcomb.Object</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Object.Object" id="apidoc.element.tcomb.Object.Object">
        function <span class="apidocSignatureSpan">tcomb.</span>Object
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Object.is" id="apidoc.element.tcomb.Object.is">
        function <span class="apidocSignatureSpan">tcomb.Object.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(x) {
  return !isNil(x) &amp;&amp; typeof x === 'object' &amp;&amp; !isArray(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Object.meta" id="apidoc.module.tcomb.Object.meta">module tcomb.Object.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Object.meta.predicate" id="apidoc.element.tcomb.Object.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Object.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(x) {
  return !isNil(x) &amp;&amp; typeof x === 'object' &amp;&amp; !isArray(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.RegExp" id="apidoc.module.tcomb.RegExp">module tcomb.RegExp</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.RegExp.RegExp" id="apidoc.element.tcomb.RegExp.RegExp">
        function <span class="apidocSignatureSpan">tcomb.</span>RegExp
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.RegExp.is" id="apidoc.element.tcomb.RegExp.is">
        function <span class="apidocSignatureSpan">tcomb.RegExp.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is = function (x) { return x instanceof RegExp; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.RegExp.meta" id="apidoc.module.tcomb.RegExp.meta">module tcomb.RegExp.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.RegExp.meta.predicate" id="apidoc.element.tcomb.RegExp.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.RegExp.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predicate = function (x) { return x instanceof RegExp; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.String" id="apidoc.module.tcomb.String">module tcomb.String</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.String.String" id="apidoc.element.tcomb.String.String">
        function <span class="apidocSignatureSpan">tcomb.</span>String
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.String.is" id="apidoc.element.tcomb.String.is">
        function <span class="apidocSignatureSpan">tcomb.String.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(x) {
  return typeof x === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.String.meta" id="apidoc.module.tcomb.String.meta">module tcomb.String.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.String.meta.predicate" id="apidoc.element.tcomb.String.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.String.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(x) {
  return typeof x === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Type" id="apidoc.module.tcomb.Type">module tcomb.Type</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.Type.Type" id="apidoc.element.tcomb.Type.Type">
        function <span class="apidocSignatureSpan">tcomb.</span>Type
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.Type.is" id="apidoc.element.tcomb.Type.is">
        function <span class="apidocSignatureSpan">tcomb.Type.</span>is
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isType(x) {
  return isFunction(x) &amp;&amp; isObject(x.meta);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.Type.meta" id="apidoc.module.tcomb.Type.meta">module tcomb.Type.meta</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.Type.meta.predicate" id="apidoc.element.tcomb.Type.meta.predicate">
        function <span class="apidocSignatureSpan">tcomb.Type.meta.</span>predicate
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isType(x) {
  return isFunction(x) &amp;&amp; isObject(x.meta);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'maybe' :
  return isNil(value) ? null : fromJSON(value, type.meta.type, path);

case 'subtype' : // the kind of a refinement is 'subtype' (for legacy reasons)
  ret = fromJSON(value, type.meta.type, path);
  if (process.env.NODE_ENV !== 'production') {
    assert(type.meta.<span class="apidocCodeKeywordSpan">predicate</span>(ret), function () {
      return 'Invalid argument value ' + assert.stringify(value) + ' supplied to fromJSON(value, type) (expected
a valid ' + getTypeName(type) + ')';
    });
  }
  return ret;

case 'struct' :
  if (process.env.NODE_ENV !== 'production') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.assert" id="apidoc.module.tcomb.assert">module tcomb.assert</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.assert.assert" id="apidoc.element.tcomb.assert.assert">
        function <span class="apidocSignatureSpan">tcomb.</span>assert
        <span class="apidocSignatureSpan">(guard, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assert(guard, message) {
  if (guard !== true) {
    if (isFunction(message)) { // handle lazy messages
      message = message();
    }
    else if (isNil(message)) { // use a default message
      message = 'Assert failed (turn on "Pause on exceptions" in your Source panel)';
    }
    assert.fail(message);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Any" id="apidoc.element.tcomb.assert.Any">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Any
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Arr" id="apidoc.element.tcomb.assert.Arr">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Arr
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Array" id="apidoc.element.tcomb.assert.Array">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Array
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Bool" id="apidoc.element.tcomb.assert.Bool">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Bool
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Boolean" id="apidoc.element.tcomb.assert.Boolean">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Boolean
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Dat" id="apidoc.element.tcomb.assert.Dat">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Dat
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Date" id="apidoc.element.tcomb.assert.Date">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Date
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Err" id="apidoc.element.tcomb.assert.Err">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Err
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Error" id="apidoc.element.tcomb.assert.Error">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Error
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Func" id="apidoc.element.tcomb.assert.Func">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Func
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Function" id="apidoc.element.tcomb.assert.Function">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Function
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Integer" id="apidoc.element.tcomb.assert.Integer">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Integer
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Refinement(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    if (identity) {
      forbidNewOperator(this, Refinement);
    }
    path = path || [displayName];
  }

  var x = create(type, value, path);

  if (process.env.NODE_ENV !== 'production') {
    assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.IntegerT" id="apidoc.element.tcomb.assert.IntegerT">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>IntegerT
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Refinement(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    if (identity) {
      forbidNewOperator(this, Refinement);
    }
    path = path || [displayName];
  }

  var x = create(type, value, path);

  if (process.env.NODE_ENV !== 'production') {
    assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Nil" id="apidoc.element.tcomb.assert.Nil">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Nil
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Num" id="apidoc.element.tcomb.assert.Num">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Num
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Number" id="apidoc.element.tcomb.assert.Number">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Number
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

A type-checked function:

```js
import t from 'tcomb';

function sum(a, b) {
  t.<span class="apidocCodeKeywordSpan">Number</span>(a);
  t.Number(b);
  return a + b;
}

sum(1, 's'); // throws '[tcomb] Invalid value "s" supplied to Number'

// using babel-plugin-tcomb
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Obj" id="apidoc.element.tcomb.assert.Obj">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Obj
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Object" id="apidoc.element.tcomb.assert.Object">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Object
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Re" id="apidoc.element.tcomb.assert.Re">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Re
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.RegExp" id="apidoc.element.tcomb.assert.RegExp">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>RegExp
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Str" id="apidoc.element.tcomb.assert.Str">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Str
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.String" id="apidoc.element.tcomb.assert.String">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>String
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.Type" id="apidoc.element.tcomb.assert.Type">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>Type
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.TypeT" id="apidoc.element.tcomb.assert.TypeT">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>TypeT
        <span class="apidocSignatureSpan">(value, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Irreducible(value, path) {

  if (process.env.NODE_ENV !== 'production') {
    forbidNewOperator(this, Irreducible);
    path = path || [name];
    assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.declare" id="apidoc.element.tcomb.assert.declare">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>declare
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function declare(name) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string
)'; });
  }

  var type;

  function Declare(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      assert(!isNil(type), function () { return 'Type declared but not defined, don\'t forget to call .define on every declared
type'; });
      if (isUnion(type)) {
        assert(type.dispatch === Declare.dispatch, function () { return 'Please define the custom ' + name + '.dispatch function
 before calling ' + name + '.define()'; });
      }
    }
    return type(value, path);
  }

  Declare.define = function (spec) {
    if (process.env.NODE_ENV !== 'production') {
      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (
expected a type)'; });
      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
      assert(isNil(spec.meta.name) &amp;&amp; Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' +
assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
    }

    if (isUnion(spec) &amp;&amp; Declare.hasOwnProperty('dispatch')) {
      spec.dispatch = Declare.dispatch;
    }
    type = spec;
    mixin(Declare, type, true); // true because it overwrites Declare.displayName
    if (name) {
      type.displayName = Declare.displayName = name;
      Declare.meta.name = name;
    }
    Declare.meta.identity = type.meta.identity;
    Declare.prototype = type.prototype;
    return Declare;
  };

  Declare.displayName = name || ( getTypeName(Declare) + "$" + nextDeclareUniqueId++ );
  // in general I can't say if this type will be an identity, for safety setting to false
  Declare.meta = { identity: false };
  Declare.prototype = null;
  return Declare;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.dict" id="apidoc.element.tcomb.assert.dict">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>dict
        <span class="apidocSignatureSpan">(domain, codomain, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dict(domain, codomain, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain
, codomain, [name]) combinator (expected a type)'; });
    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to
dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain,
codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainNameCache = getTypeName(domain);
  var codomainNameCache = getTypeName(codomain);
  var identity = isIdentity(domain) &amp;&amp; isIdentity(codomain);

  function Dict(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true
    for (var k in value) {
      if (value.hasOwnProperty(k)) {
        k = create(domain, k, ( process.env.NODE_ENV !== 'production' ? path.concat(domainNameCache) : null ));
        var actual = value[k];
        var instance = create(codomain, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + codomainNameCache
) : null ));
        idempotent = idempotent &amp;&amp; ( actual === instance );
        ret[k] = instance;
      }
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Dict.meta = {
    kind: 'dict',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: identity
  };

  Dict.displayName = displayName;

  Dict.is = function (x) {
    if (!isObject(x)) {
      return false;
    }
    for (var k in x) {
      if (x.hasOwnProperty(k)) {
        if (!is(k, domain) || !is(x[k], codomain)) {
          return false;
        }
      }
    }
    return true;
  };

  Dict.update = function (instance, patch) {
    return Dict(assert.update(instance, patch));
  };

  return Dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.enums" id="apidoc.element.tcomb.assert.enums">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>enums
        <span class="apidocSignatureSpan">(map, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enums(map, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name])
combinator (expected a dictionary of String -&gt; String | Number)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(map);

  function Enums(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Enums);
      path = path || [displayName];
      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected one of ' + assert.stringify(Object.keys(map)) + ')'; });
    }

    return value;
  }

  Enums.meta = {
    kind: 'enums',
    map: map,
    name: name,
    identity: true
  };

  Enums.displayName = displayName;

  Enums.is = function (x) {
    return map.hasOwnProperty(x);
  };

  return Enums;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.fail" id="apidoc.element.tcomb.assert.fail">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>fail
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fail(message) {
  throw new TypeError('[tcomb] ' + message);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
    }

    if (type.is(x) &amp;&amp; guard(x)) {
      return f(x);
    }
  }
  assert.<span class="apidocCodeKeywordSpan">fail</span>('Match error');
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.func" id="apidoc.element.tcomb.assert.func">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>func
        <span class="apidocSignatureSpan">(domain, codomain, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function func(domain, codomain, name) {

  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions

  if (process.env.NODE_ENV !== 'production') {
    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied
 to func(domain, codomain, [name]) combinator (expected an array of types)'; });
    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied
 to func(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain,
codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainLength = domain.length;
  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);

  function FuncType(value, path) {

    if (!isInstrumented(value)) { // automatically instrument the function
      return FuncType.of(value);
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  FuncType.meta = {
    kind: 'func',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: true
  };

  FuncType.displayName = displayName;

  FuncType.is = function (x) {
    return isInstrumented(x) &amp;&amp;
      x.instrumentation.domain.length === domainLength &amp;&amp;
      x.instrumentation.domain.every(function (type, i) {
        return type === domain[i];
      }) &amp;&amp;
      x.instrumentation.codomain === codomain;
  };

  FuncType.of = function (f, curried) {

    if (process.env.NODE_ENV !== 'production') {
      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function
)'; });
      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + '
supplied to func.of ' + displayName + ' (expected a boolean)'; });
    }

    if (FuncType.is(f)) { // makes FuncType.of idempotent
      return f;
    }

    function fn() {
      var args = Array.prototype.slice.call(arguments);
      var argsLength = args.length;

      if (process.env.NODE_ENV !== 'production') {
        // type-check arguments
        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);
        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);
      }

      if (curried &amp;&amp; argsLength &lt; domainLength) {
        if (process.env.NODE_ENV !== 'production') {
          assert(argsLength &gt; 0, 'Invalid arguments.length = 0 for curried function ' + displayName);
        }
        var g = Function.prototype.bind.apply(f, [this].concat(args));
        var newDomain = func(domain.slice(argsLength), codomain);
        return newDomain.of(g, true);
      }
      else {
        return create(codomain, f.apply(this, args));
      }
    }

    fn.instrumentation = {
      domain: domain,
      codomain: codomain,
      f: f
    };

    fn.displayName = getFunctionName(f);

    return fn;

  };

  return FuncType;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.getTypeName" id="apidoc.element.tcomb.assert.getTypeName">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>getTypeName
        <span class="apidocSignatureSpan">(ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTypeName(ctor) {
  if (isType(ctor)) {
    return ctor.displayName;
  }
  return getFunctionName(ctor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.inter" id="apidoc.element.tcomb.assert.inter">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>inter
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inter(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to interface(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
  }

  var displayName = name || getDefaultInterfaceName(props);
  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);

  function Interface(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
      // strictness
      if (strict) {
        for (var k in value) {
          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
        }
      }
    }

    var idempotent = true;
    var ret = identity ? {} : assign({}, value);
    for (var prop in props) {
      var expected = props[prop];
      var actual = value[prop];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret[prop] = instance;
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;

  }

  Interface.meta = {
    kind: 'interface',
    props: props,
    name: name,
    identity: identity,
    strict: strict
  };

  Interface.displayName = displayName;

  Interface.is = function (x) {
    if (isNil(x)) {
      return false;
    }
    if (strict) {
      for (var k in x) {
        if (!props.hasOwnProperty(k)) {
          return false;
        }
      }
    }
    for (var prop in props) {
      if (!is(x[prop], props[prop])) {
        return false;
      }
    }
    return true;
  };

  Interface.update = function (instance, patch) {
    return Interface(assert.update(instance, patch));
  };

  Interface.extend = function (xs, name) {
    return extendInterface([Interface].concat(xs), name);
  };

  return Interface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.interface" id="apidoc.element.tcomb.assert.interface">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>interface
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inter(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to interface(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
  }

  var displayName = name || getDefaultInterfaceName(props);
  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);

  function Interface(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
      // strictness
      if (strict) {
        for (var k in value) {
          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
        }
      }
    }

    var idempotent = true;
    var ret = identity ? {} : assign({}, value);
    for (var prop in props) {
      var expected = props[prop];
      var actual = value[prop];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret[prop] = instance;
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;

  }

  Interface.meta = {
    kind: 'interface',
    props: props,
    name: name,
    identity: identity,
    strict: strict
  };

  Interface.displayName = displayName;

  Interface.is = function (x) {
    if (isNil(x)) {
      return false;
    }
    if (strict) {
      for (var k in x) {
        if (!props.hasOwnProperty(k)) {
          return false;
        }
      }
    }
    for (var prop in props) {
      if (!is(x[prop], props[prop])) {
        return false;
      }
    }
    return true;
  };

  Interface.update = function (instance, patch) {
    return Interface(assert.update(instance, patch));
  };

  Interface.extend = function (xs, name) {
    return extendInterface([Interface].concat(xs), name);
  };

  return Interface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.intersection" id="apidoc.element.tcomb.assert.intersection">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>intersection
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersection(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction) &amp;&amp; types.length &gt;= 2, function () { return 'Invalid argument types ' + assert
.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection
(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Intersection(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Intersection);
      }
      path = path || [displayName];
      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join
('/'); });
    }

    return value;
  }

  Intersection.meta = {
    kind: 'intersection',
    types: types,
    name: name,
    identity: identity
  };

  Intersection.displayName = displayName;

  Intersection.is = function (x) {
    return types.every(function (type) {
      return is(x, type);
    });
  };

  Intersection.update = function (instance, patch) {
    return Intersection(assert.update(instance, patch));
  };

  return Intersection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.irreducible" id="apidoc.element.tcomb.assert.irreducible">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>irreducible
        <span class="apidocSignatureSpan">(name, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function irreducible(name, predicate) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isString(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name
, predicate) (expected a string)'; });
    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name,
predicate) (expected a function)');
  }

  function Irreducible(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Irreducible);
      path = path || [name];
      assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  Irreducible.meta = {
    kind: 'irreducible',
    name: name,
    predicate: predicate,
    identity: true
  };

  Irreducible.displayName = name;

  Irreducible.is = predicate;

  return Irreducible;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.is" id="apidoc.element.tcomb.assert.is">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>is
        <span class="apidocSignatureSpan">(x, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function is(x, type) {
  if (isType(type)) {
    return type.is(x);
  }
  return x instanceof type; // type should be a class constructor
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.<span class="apidocCodeKeywordSpan">is</span>(x);
  }
  return x instanceof type; // type should be a class constructor
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.isType" id="apidoc.element.tcomb.assert.isType">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>isType
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isType(x) {
  return isFunction(x) &amp;&amp; isObject(x.meta);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.list" id="apidoc.element.tcomb.assert.list">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>list
        <span class="apidocSignatureSpan">(type, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function list(type, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [
name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var typeNameCache = getTypeName(type);
  var identity = isIdentity(type); // the list is identity iif type is identity

  function List(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected an array of ' + typeNameCache + ')'; });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = []; // make a temporary copy, will be discarded if idempotent remains true
    for (var i = 0, len = value.length; i &lt; len; i++ ) {
      var actual = value[i];
      var instance = create(type, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null
 ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  List.meta = {
    kind: 'list',
    type: type,
    name: name,
    identity: identity
  };

  List.displayName = displayName;

  List.is = function (x) {
    return isArray(x) &amp;&amp; x.every(function (e) {
      return is(e, type);
    });
  };

  List.update = function (instance, patch) {
    return List(assert.update(instance, patch));
  };

  return List;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A type-checked class:

```js
const Person = t.struct({
  name: t.String,              // required string
  surname: t.maybe(t.String),  // optional string
  age: t.Integer,                // required integer
  tags: t.<span class="apidocCodeKeywordSpan">list</span>(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
Person.prototype.getFullName = function () {
  return `${this.name} ${this.surname}`;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.match" id="apidoc.element.tcomb.assert.match">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>match
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(x) {
  var type, guard, f, count;
  for (var i = 1, len = arguments.length; i &lt; len; ) {
    type = arguments[i];
    guard = arguments[i + 1];
    f = arguments[i + 2];

    if (isFunction(f) &amp;&amp; !isType(f)) {
      i = i + 3;
    }
    else {
      f = guard;
      guard = Any.is;
      i = i + 2;
    }

    if (process.env.NODE_ENV !== 'production') {
      count = (count || 0) + 1;
      assert(isType(type), function () { return 'Invalid type in clause #' + count; });
      assert(isFunction(guard), function () { return 'Invalid guard in clause #' + count; });
      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
    }

    if (type.is(x) &amp;&amp; guard(x)) {
      return f(x);
    }
  }
  assert.fail('Match error');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.error(message);
};
```

**Pattern matching**

```js
const result = t.<span class="apidocCodeKeywordSpan">match</span>(1,
  t.String, () =&gt; 'a string',
  t.Number, () =&gt; 'a number'
);

console.log(result); // =&gt; 'a number'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.maybe" id="apidoc.element.tcomb.assert.maybe">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>maybe
        <span class="apidocSignatureSpan">(type, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function maybe(type, name) {

  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil
    return type;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [
name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var identity = isIdentity(type);

  function Maybe(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Maybe);
      }
    }
    return Nil.is(value) ? value : create(type, value, path);
  }

  Maybe.meta = {
    kind: 'maybe',
    type: type,
    name: name,
    identity: identity
  };

  Maybe.displayName = displayName;

  Maybe.is = function (x) {
    return Nil.is(x) || is(x, type);
  };

  return Maybe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A type-checked class:

```js
const Person = t.struct({
name: t.String,              // required string
surname: t.<span class="apidocCodeKeywordSpan">maybe</span>(t.String),  // optional string
age: t.Integer,                // required integer
tags: t.list(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
Person.prototype.getFullName = function () {
return `${this.name} ${this.surname}`;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.mixin" id="apidoc.element.tcomb.assert.mixin">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>mixin
        <span class="apidocSignatureSpan">(target, source, overwrite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mixin(target, source, overwrite) {
  if (isNil(source)) { return target; }
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      if (overwrite !== true) {
        if (process.env.NODE_ENV !== 'production') {
          assert(!target.hasOwnProperty(k) || target[k] === source[k], function () { return 'Invalid call to mixin(target, source
, [overwrite]): cannot overwrite property "' + k + '" of target object'; });
        }
      }
      target[k] = source[k];
    }
  }
  return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.refinement" id="apidoc.element.tcomb.assert.refinement">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>refinement
        <span class="apidocSignatureSpan">(type, predicate, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refinement(type, predicate, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name
]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Refinement);
      }
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (process.env.NODE_ENV !== 'production') {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) &amp;&amp; predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return a + b;
}
```

A user defined type:

```js
const Integer = t.<span class="apidocCodeKeywordSpan">refinement</span>(t.Number, (n) =&gt; n % 1 === 0, 'Integer');
```

A type-checked class:

```js
const Person = t.struct({
name: t.String,              // required string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.stringify" id="apidoc.element.tcomb.assert.stringify">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>stringify
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringify(x) {
  try { // handle "Converting circular structure to JSON" error
    return JSON.stringify(x, replacer, 2);
  }
  catch (e) {
    return String(x);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
return type(value, path);
  }

  Declare.define = function (spec) {
if (process.env.NODE_ENV !== 'production') {
  assert(isType(spec), function () { return 'Invalid argument type ' + assert.<span class="apidocCodeKeywordSpan">stringify
</span>(spec) +  ' supplied to define(type) (expected a type)'; });
  assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
  assert(isNil(spec.meta.name) &amp;&amp; Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument
 type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
}

if (isUnion(spec) &amp;&amp; Declare.hasOwnProperty('dispatch')) {
  spec.dispatch = Declare.dispatch;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.struct" id="apidoc.element.tcomb.assert.struct">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>struct
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function struct(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;
  var defaultProps = options.defaultProps;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to struct(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
    assert(isObject(defaultProps), function () { return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied
 to struct(props, [options]) combinator (expected an object)'; });
  }

  var displayName = name || getDefaultName(props);

  function Struct(value, path) {

    if (Struct.is(value)) { // implements idempotency
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected an object)'; });
      // strictness
      if (strict) {
        for (k in value) {
          if (value.hasOwnProperty(k)) {
            assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
          }
        }
      }
    }

    if (!(this instanceof Struct)) { // `new` is optional
      return new Struct(value, path);
    }

    for (var k in props) {
      if (props.hasOwnProperty(k)) {
        var expected = props[k];
        var actual = value[k];
        // apply defaults
        if (actual === undefined) {
          actual = defaultProps[k];
        }
        this[k] = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + getTypeName(expected
)) : null ));
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(this);
    }

  }

  Struct.meta = {
    kind: 'struct',
    props: props,
    name: name,
    identity: false,
    strict: strict,
    defaultProps: defaultProps
  };

  Struct.displayName = displayName;

  Struct.is = function (x) {
    return x instanceof Struct;
  };

  Struct.update = function (instance, patch) {
    return new Struct(assert.update(instance, patch));
  };

  Struct.extend = function (xs, name) {
    return extendStruct([Struct].concat(xs), name);
  };

  return Struct;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
const Integer = t.refinement(t.Number, (n) =&gt; n % 1 === 0, 'Integer');
```

A type-checked class:

```js
const Person = t.<span class="apidocCodeKeywordSpan">struct</span>({
  name: t.String,              // required string
  surname: t.maybe(t.String),  // optional string
  age: t.Integer,                // required integer
  tags: t.list(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.subtype" id="apidoc.element.tcomb.assert.subtype">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>subtype
        <span class="apidocSignatureSpan">(type, predicate, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refinement(type, predicate, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name
]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Refinement);
      }
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (process.env.NODE_ENV !== 'production') {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) &amp;&amp; predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.tuple" id="apidoc.element.tcomb.assert.tuple">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>tuple
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tuple(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + '
supplied to tuple(types, [name]) combinator (expected an array of types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Tuple(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value) &amp;&amp; value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + '
supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });
    }

    var idempotent = true;
    var ret = [];
    for (var i = 0, len = types.length; i &lt; len; i++) {
      var expected = types[i];
      var actual = value[i];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Tuple.meta = {
    kind: 'tuple',
    types: types,
    name: name,
    identity: identity
  };

  Tuple.displayName = displayName;

  Tuple.is = function (x) {
    return isArray(x) &amp;&amp;
      x.length === types.length &amp;&amp;
      types.every(function (type, i) {
        return is(x[i], type);
      });
  };

  Tuple.update = function (instance, patch) {
    return Tuple(assert.update(instance, patch));
  };

  return Tuple;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.union" id="apidoc.element.tcomb.assert.union">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>union
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function union(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction) &amp;&amp; types.length &gt;= 2, function () { return 'Invalid argument types ' + assert
.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Union(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    var type = Union.dispatch(value);
    if (!type &amp;&amp; Union.is(value)) {
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Union);
      }
      path = path || [displayName];
      assert(isFunction(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
no constructor returned by dispatch)'; });
      path[path.length - 1] += '(' + getTypeName(type) + ')';
    }

    return create(type, value, path);
  }

  Union.meta = {
    kind: 'union',
    types: types,
    name: name,
    identity: identity
  };

  Union.displayName = displayName;

  Union.is = function (x) {
    return types.some(function (type) {
      return is(x, type);
    });
  };

  Union.dispatch = function (x) { // default dispatch implementation
    for (var i = 0, len = types.length; i &lt; len; i++ ) {
      var type = types[i];
      if (isUnion(type)) { // handle union of unions
        var t = type.dispatch(x);
        if (!isNil(t)) {
          return t;
        }
      }
      else if (is(x, type)) {
        return type;
      }
    }
  };

  Union.update = function (instance, patch) {
    return Union(assert.update(instance, patch));
  };

  return Union;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.assert.update" id="apidoc.element.tcomb.assert.update">
        function <span class="apidocSignatureSpan">tcomb.assert.</span>update
        <span class="apidocSignatureSpan">(instance, patch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function update(instance, patch) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(patch), function () { return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update
(instance, patch): expected an object containing commands'; });
  }

  var value = instance;
  var isChanged = false;
  var newValue;
  for (var k in patch) {
    if (patch.hasOwnProperty(k)) {
      if (isCommand(k)) {
        newValue = getCommand(k)(patch[k], value);
        if (newValue !== instance) {
          isChanged = true;
          value = newValue;
        } else {
          value = instance;
        }
      }
      else {
        if (value === instance) {
          value = getShallowCopy(instance);
        }
        newValue = update(value[k], patch[k]);
        isChanged = isChanged || ( newValue !== value[k] );
        value[k] = newValue;
      }
    }
  }
  return isChanged ? value : instance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* interfaces

**Immutability and immutability helpers**

Instances are immutable using `Object.freeze`. This means you can use standard JavaScript objects and arrays. You don't have
 to change how you normally code. You can update an immutable instance with the provided `update(instance, spec)` function:

```js
const person2 = Person.<span class="apidocCodeKeywordSpan">update</span>(person, {
  name: { $set: 'Guido' }
});
```

where `spec` is an object containing *commands*. The following commands are compatible with the [Facebook Immutability Helpers](
http://facebook.github.io/react/docs/update.html):

* `$push`
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.dict" id="apidoc.module.tcomb.dict">module tcomb.dict</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.dict.dict" id="apidoc.element.tcomb.dict.dict">
        function <span class="apidocSignatureSpan">tcomb.</span>dict
        <span class="apidocSignatureSpan">(domain, codomain, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dict(domain, codomain, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain
, codomain, [name]) combinator (expected a type)'; });
    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to
dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain,
codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainNameCache = getTypeName(domain);
  var codomainNameCache = getTypeName(codomain);
  var identity = isIdentity(domain) &amp;&amp; isIdentity(codomain);

  function Dict(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true
    for (var k in value) {
      if (value.hasOwnProperty(k)) {
        k = create(domain, k, ( process.env.NODE_ENV !== 'production' ? path.concat(domainNameCache) : null ));
        var actual = value[k];
        var instance = create(codomain, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + codomainNameCache
) : null ));
        idempotent = idempotent &amp;&amp; ( actual === instance );
        ret[k] = instance;
      }
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Dict.meta = {
    kind: 'dict',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: identity
  };

  Dict.displayName = displayName;

  Dict.is = function (x) {
    if (!isObject(x)) {
      return false;
    }
    for (var k in x) {
      if (x.hasOwnProperty(k)) {
        if (!is(k, domain) || !is(x[k], codomain)) {
          return false;
        }
      }
    }
    return true;
  };

  Dict.update = function (instance, patch) {
    return Dict(assert.update(instance, patch));
  };

  return Dict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.dict.getDefaultName" id="apidoc.element.tcomb.dict.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.dict.</span>getDefaultName
        <span class="apidocSignatureSpan">(domain, codomain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(domain, codomain) {
  return '{[key: ' + getTypeName(domain) + ']: ' + getTypeName(codomain) + '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.enums" id="apidoc.module.tcomb.enums">module tcomb.enums</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.enums.enums" id="apidoc.element.tcomb.enums.enums">
        function <span class="apidocSignatureSpan">tcomb.</span>enums
        <span class="apidocSignatureSpan">(map, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enums(map, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name])
combinator (expected a dictionary of String -&gt; String | Number)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(map);

  function Enums(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Enums);
      path = path || [displayName];
      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected one of ' + assert.stringify(Object.keys(map)) + ')'; });
    }

    return value;
  }

  Enums.meta = {
    kind: 'enums',
    map: map,
    name: name,
    identity: true
  };

  Enums.displayName = displayName;

  Enums.is = function (x) {
    return map.hasOwnProperty(x);
  };

  return Enums;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.enums.getDefaultName" id="apidoc.element.tcomb.enums.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.enums.</span>getDefaultName
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(map) {
  return Object.keys(map).map(function (k) { return assert.stringify(k); }).join(' | ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.enums.of" id="apidoc.element.tcomb.enums.of">
        function <span class="apidocSignatureSpan">tcomb.enums.</span>of
        <span class="apidocSignatureSpan">(keys, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function (keys, name) {
  keys = isString(keys) ? keys.split(' ') : keys;
  var value = {};
  keys.forEach(function (k) {
    value[k] = k;
  });
  return enums(value, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.func" id="apidoc.module.tcomb.func">module tcomb.func</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.func.func" id="apidoc.element.tcomb.func.func">
        function <span class="apidocSignatureSpan">tcomb.</span>func
        <span class="apidocSignatureSpan">(domain, codomain, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function func(domain, codomain, name) {

  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions

  if (process.env.NODE_ENV !== 'production') {
    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied
 to func(domain, codomain, [name]) combinator (expected an array of types)'; });
    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied
 to func(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain,
codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainLength = domain.length;
  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);

  function FuncType(value, path) {

    if (!isInstrumented(value)) { // automatically instrument the function
      return FuncType.of(value);
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  FuncType.meta = {
    kind: 'func',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: true
  };

  FuncType.displayName = displayName;

  FuncType.is = function (x) {
    return isInstrumented(x) &amp;&amp;
      x.instrumentation.domain.length === domainLength &amp;&amp;
      x.instrumentation.domain.every(function (type, i) {
        return type === domain[i];
      }) &amp;&amp;
      x.instrumentation.codomain === codomain;
  };

  FuncType.of = function (f, curried) {

    if (process.env.NODE_ENV !== 'production') {
      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function
)'; });
      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + '
supplied to func.of ' + displayName + ' (expected a boolean)'; });
    }

    if (FuncType.is(f)) { // makes FuncType.of idempotent
      return f;
    }

    function fn() {
      var args = Array.prototype.slice.call(arguments);
      var argsLength = args.length;

      if (process.env.NODE_ENV !== 'production') {
        // type-check arguments
        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);
        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);
      }

      if (curried &amp;&amp; argsLength &lt; domainLength) {
        if (process.env.NODE_ENV !== 'production') {
          assert(argsLength &gt; 0, 'Invalid arguments.length = 0 for curried function ' + displayName);
        }
        var g = Function.prototype.bind.apply(f, [this].concat(args));
        var newDomain = func(domain.slice(argsLength), codomain);
        return newDomain.of(g, true);
      }
      else {
        return create(codomain, f.apply(this, args));
      }
    }

    fn.instrumentation = {
      domain: domain,
      codomain: codomain,
      f: f
    };

    fn.displayName = getFunctionName(f);

    return fn;

  };

  return FuncType;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.func.getDefaultName" id="apidoc.element.tcomb.func.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.func.</span>getDefaultName
        <span class="apidocSignatureSpan">(domain, codomain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(domain, codomain) {
  return '(' + domain.map(getTypeName).join(', ') + ') =&gt; ' + getTypeName(codomain);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.func.getOptionalArgumentsIndex" id="apidoc.element.tcomb.func.getOptionalArgumentsIndex">
        function <span class="apidocSignatureSpan">tcomb.func.</span>getOptionalArgumentsIndex
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOptionalArgumentsIndex(types) {
  var end = types.length;
  var areAllMaybes = false;
  for (var i = end - 1; i &gt;= 0; i--) {
    var type = types[i];
    if (!isType(type) || type.meta.kind !== 'maybe') {
      return (i + 1);
    } else {
      areAllMaybes = true;
    }
  }
  return areAllMaybes ? 0 : end;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.inter" id="apidoc.module.tcomb.inter">module tcomb.inter</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.inter.inter" id="apidoc.element.tcomb.inter.inter">
        function <span class="apidocSignatureSpan">tcomb.</span>inter
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inter(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to interface(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
  }

  var displayName = name || getDefaultInterfaceName(props);
  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);

  function Interface(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
      // strictness
      if (strict) {
        for (var k in value) {
          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
        }
      }
    }

    var idempotent = true;
    var ret = identity ? {} : assign({}, value);
    for (var prop in props) {
      var expected = props[prop];
      var actual = value[prop];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret[prop] = instance;
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;

  }

  Interface.meta = {
    kind: 'interface',
    props: props,
    name: name,
    identity: identity,
    strict: strict
  };

  Interface.displayName = displayName;

  Interface.is = function (x) {
    if (isNil(x)) {
      return false;
    }
    if (strict) {
      for (var k in x) {
        if (!props.hasOwnProperty(k)) {
          return false;
        }
      }
    }
    for (var prop in props) {
      if (!is(x[prop], props[prop])) {
        return false;
      }
    }
    return true;
  };

  Interface.update = function (instance, patch) {
    return Interface(assert.update(instance, patch));
  };

  Interface.extend = function (xs, name) {
    return extendInterface([Interface].concat(xs), name);
  };

  return Interface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.inter.extend" id="apidoc.element.tcomb.inter.extend">
        function <span class="apidocSignatureSpan">tcomb.inter.</span>extend
        <span class="apidocSignatureSpan">(mixins, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendInterface(mixins, name) {
  return extend(inter, mixins, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.inter.getDefaultName" id="apidoc.element.tcomb.inter.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.inter.</span>getDefaultName
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultInterfaceName(props) {
  return '{' + Object.keys(props).map(function (prop) {
    return prop + ': ' + getTypeName(props[prop]);
  }).join(', ') + '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.inter.getOptions" id="apidoc.element.tcomb.inter.getOptions">
        function <span class="apidocSignatureSpan">tcomb.inter.</span>getOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOptions(options) {
  if (!isObject(options)) {
    options = isNil(options) ? {} : { name: options };
  }
  if (!options.hasOwnProperty('strict')) {
    options.strict = inter.strict;
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () { return 'Invalid
 argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or
a refinement (of struct or interface)'; });
    }
    pushAll(predicates, decomposition.predicates);
    mixin(props, getProps(unrefinedType));
    mixin(prototype, unrefinedType.prototype);
    mixin(defaultProps, getDefaultProps(unrefinedType), true);
  });
  options = combinator.<span class="apidocCodeKeywordSpan">getOptions</span>(options);
  options.defaultProps = mixin(defaultProps, options.defaultProps, true);
  var result = compose(predicates, combinator(props, options));
  mixin(result.prototype, prototype);
  return result;
}

module.exports = extend;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.intersection" id="apidoc.module.tcomb.intersection">module tcomb.intersection</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.intersection.intersection" id="apidoc.element.tcomb.intersection.intersection">
        function <span class="apidocSignatureSpan">tcomb.</span>intersection
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersection(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction) &amp;&amp; types.length &gt;= 2, function () { return 'Invalid argument types ' + assert
.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection
(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Intersection(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Intersection);
      }
      path = path || [displayName];
      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join
('/'); });
    }

    return value;
  }

  Intersection.meta = {
    kind: 'intersection',
    types: types,
    name: name,
    identity: identity
  };

  Intersection.displayName = displayName;

  Intersection.is = function (x) {
    return types.every(function (type) {
      return is(x, type);
    });
  };

  Intersection.update = function (instance, patch) {
    return Intersection(assert.update(instance, patch));
  };

  return Intersection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.intersection.getDefaultName" id="apidoc.element.tcomb.intersection.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.intersection.</span>getDefaultName
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(types) {
  return types.map(getTypeName).join(' &amp; ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.list" id="apidoc.module.tcomb.list">module tcomb.list</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.list.list" id="apidoc.element.tcomb.list.list">
        function <span class="apidocSignatureSpan">tcomb.</span>list
        <span class="apidocSignatureSpan">(type, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function list(type, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [
name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var typeNameCache = getTypeName(type);
  var identity = isIdentity(type); // the list is identity iif type is identity

  function List(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected an array of ' + typeNameCache + ')'; });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = []; // make a temporary copy, will be discarded if idempotent remains true
    for (var i = 0, len = value.length; i &lt; len; i++ ) {
      var actual = value[i];
      var instance = create(type, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null
 ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  List.meta = {
    kind: 'list',
    type: type,
    name: name,
    identity: identity
  };

  List.displayName = displayName;

  List.is = function (x) {
    return isArray(x) &amp;&amp; x.every(function (e) {
      return is(e, type);
    });
  };

  List.update = function (instance, patch) {
    return List(assert.update(instance, patch));
  };

  return List;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A type-checked class:

```js
const Person = t.struct({
  name: t.String,              // required string
  surname: t.maybe(t.String),  // optional string
  age: t.Integer,                // required integer
  tags: t.<span class="apidocCodeKeywordSpan">list</span>(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
Person.prototype.getFullName = function () {
  return `${this.name} ${this.surname}`;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.list.getDefaultName" id="apidoc.element.tcomb.list.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.list.</span>getDefaultName
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(type) {
  return 'Array&lt;' + getTypeName(type) + '&gt;';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.maybe" id="apidoc.module.tcomb.maybe">module tcomb.maybe</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.maybe.maybe" id="apidoc.element.tcomb.maybe.maybe">
        function <span class="apidocSignatureSpan">tcomb.</span>maybe
        <span class="apidocSignatureSpan">(type, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function maybe(type, name) {

  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil
    return type;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [
name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var identity = isIdentity(type);

  function Maybe(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Maybe);
      }
    }
    return Nil.is(value) ? value : create(type, value, path);
  }

  Maybe.meta = {
    kind: 'maybe',
    type: type,
    name: name,
    identity: identity
  };

  Maybe.displayName = displayName;

  Maybe.is = function (x) {
    return Nil.is(x) || is(x, type);
  };

  return Maybe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A type-checked class:

```js
const Person = t.struct({
name: t.String,              // required string
surname: t.<span class="apidocCodeKeywordSpan">maybe</span>(t.String),  // optional string
age: t.Integer,                // required integer
tags: t.list(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
Person.prototype.getFullName = function () {
return `${this.name} ${this.surname}`;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.maybe.getDefaultName" id="apidoc.element.tcomb.maybe.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.maybe.</span>getDefaultName
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(type) {
  return '?' + getTypeName(type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.refinement" id="apidoc.module.tcomb.refinement">module tcomb.refinement</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.refinement.refinement" id="apidoc.element.tcomb.refinement.refinement">
        function <span class="apidocSignatureSpan">tcomb.</span>refinement
        <span class="apidocSignatureSpan">(type, predicate, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refinement(type, predicate, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name
]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type
, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Refinement);
      }
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (process.env.NODE_ENV !== 'production') {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) &amp;&amp; predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return a + b;
}
```

A user defined type:

```js
const Integer = t.<span class="apidocCodeKeywordSpan">refinement</span>(t.Number, (n) =&gt; n % 1 === 0, 'Integer');
```

A type-checked class:

```js
const Person = t.struct({
name: t.String,              // required string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.refinement.getDefaultName" id="apidoc.element.tcomb.refinement.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.refinement.</span>getDefaultName
        <span class="apidocSignatureSpan">(type, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(type, predicate) {
  return '{' + getTypeName(type) + ' | ' + getFunctionName(predicate) + '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.struct" id="apidoc.module.tcomb.struct">module tcomb.struct</a></h1>




    <h2>
        <a href="#apidoc.element.tcomb.struct.struct" id="apidoc.element.tcomb.struct.struct">
        function <span class="apidocSignatureSpan">tcomb.</span>struct
        <span class="apidocSignatureSpan">(props, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function struct(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;
  var defaultProps = options.defaultProps;

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied
 to struct(props, [options]) combinator (expected a dictionary String -&gt; Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props
, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(
props, [options]) combinator (expected a boolean)'; });
    assert(isObject(defaultProps), function () { return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied
 to struct(props, [options]) combinator (expected an object)'; });
  }

  var displayName = name || getDefaultName(props);

  function Struct(value, path) {

    if (Struct.is(value)) { // implements idempotency
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
expected an object)'; });
      // strictness
      if (strict) {
        for (k in value) {
          if (value.hasOwnProperty(k)) {
            assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
          }
        }
      }
    }

    if (!(this instanceof Struct)) { // `new` is optional
      return new Struct(value, path);
    }

    for (var k in props) {
      if (props.hasOwnProperty(k)) {
        var expected = props[k];
        var actual = value[k];
        // apply defaults
        if (actual === undefined) {
          actual = defaultProps[k];
        }
        this[k] = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + getTypeName(expected
)) : null ));
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(this);
    }

  }

  Struct.meta = {
    kind: 'struct',
    props: props,
    name: name,
    identity: false,
    strict: strict,
    defaultProps: defaultProps
  };

  Struct.displayName = displayName;

  Struct.is = function (x) {
    return x instanceof Struct;
  };

  Struct.update = function (instance, patch) {
    return new Struct(assert.update(instance, patch));
  };

  Struct.extend = function (xs, name) {
    return extendStruct([Struct].concat(xs), name);
  };

  return Struct;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
const Integer = t.refinement(t.Number, (n) =&gt; n % 1 === 0, 'Integer');
```

A type-checked class:

```js
const Person = t.<span class="apidocCodeKeywordSpan">struct</span>({
  name: t.String,              // required string
  surname: t.maybe(t.String),  // optional string
  age: t.Integer,                // required integer
  tags: t.list(t.String)       // a list of strings
}, 'Person');

// methods are defined as usual
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.struct.extend" id="apidoc.element.tcomb.struct.extend">
        function <span class="apidocSignatureSpan">tcomb.struct.</span>extend
        <span class="apidocSignatureSpan">(mixins, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendStruct(mixins, name) {
  return extend(struct, mixins, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.struct.getDefaultName" id="apidoc.element.tcomb.struct.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.struct.</span>getDefaultName
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(props) {
  return 'Struct' + getDefaultInterfaceName(props);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.struct.getOptions" id="apidoc.element.tcomb.struct.getOptions">
        function <span class="apidocSignatureSpan">tcomb.struct.</span>getOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOptions(options) {
  if (!isObject(options)) {
    options = isNil(options) ? {} : { name: options };
  }
  if (!options.hasOwnProperty('strict')) {
    options.strict = struct.strict;
  }
  if (!options.hasOwnProperty('defaultProps')) {
    options.defaultProps = {};
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () { return 'Invalid
 argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or
a refinement (of struct or interface)'; });
    }
    pushAll(predicates, decomposition.predicates);
    mixin(props, getProps(unrefinedType));
    mixin(prototype, unrefinedType.prototype);
    mixin(defaultProps, getDefaultProps(unrefinedType), true);
  });
  options = combinator.<span class="apidocCodeKeywordSpan">getOptions</span>(options);
  options.defaultProps = mixin(defaultProps, options.defaultProps, true);
  var result = compose(predicates, combinator(props, options));
  mixin(result.prototype, prototype);
  return result;
}

module.exports = extend;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.tuple" id="apidoc.module.tcomb.tuple">module tcomb.tuple</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.tuple.tuple" id="apidoc.element.tcomb.tuple.tuple">
        function <span class="apidocSignatureSpan">tcomb.</span>tuple
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tuple(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + '
supplied to tuple(types, [name]) combinator (expected an array of types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Tuple(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value) &amp;&amp; value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + '
supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });
    }

    var idempotent = true;
    var ret = [];
    for (var i = 0, len = types.length; i &lt; len; i++) {
      var expected = types[i];
      var actual = value[i];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + getTypeName(expected
)) : null ));
      idempotent = idempotent &amp;&amp; ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Tuple.meta = {
    kind: 'tuple',
    types: types,
    name: name,
    identity: identity
  };

  Tuple.displayName = displayName;

  Tuple.is = function (x) {
    return isArray(x) &amp;&amp;
      x.length === types.length &amp;&amp;
      types.every(function (type, i) {
        return is(x[i], type);
      });
  };

  Tuple.update = function (instance, patch) {
    return Tuple(assert.update(instance, patch));
  };

  return Tuple;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.tuple.getDefaultName" id="apidoc.element.tcomb.tuple.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.tuple.</span>getDefaultName
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(types) {
  return '[' + types.map(getTypeName).join(', ') + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.tcomb.union" id="apidoc.module.tcomb.union">module tcomb.union</a></h1>


    <h2>
        <a href="#apidoc.element.tcomb.union.union" id="apidoc.element.tcomb.union.union">
        function <span class="apidocSignatureSpan">tcomb.</span>union
        <span class="apidocSignatureSpan">(types, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function union(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) &amp;&amp; types.every(isFunction) &amp;&amp; types.length &gt;= 2, function () { return 'Invalid argument types ' + assert
.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [
name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Union(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    var type = Union.dispatch(value);
    if (!type &amp;&amp; Union.is(value)) {
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (identity) {
        forbidNewOperator(this, Union);
      }
      path = path || [displayName];
      assert(isFunction(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (
no constructor returned by dispatch)'; });
      path[path.length - 1] += '(' + getTypeName(type) + ')';
    }

    return create(type, value, path);
  }

  Union.meta = {
    kind: 'union',
    types: types,
    name: name,
    identity: identity
  };

  Union.displayName = displayName;

  Union.is = function (x) {
    return types.some(function (type) {
      return is(x, type);
    });
  };

  Union.dispatch = function (x) { // default dispatch implementation
    for (var i = 0, len = types.length; i &lt; len; i++ ) {
      var type = types[i];
      if (isUnion(type)) { // handle union of unions
        var t = type.dispatch(x);
        if (!isNil(t)) {
          return t;
        }
      }
      else if (is(x, type)) {
        return type;
      }
    }
  };

  Union.update = function (instance, patch) {
    return Union(assert.update(instance, patch));
  };

  return Union;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.tcomb.union.getDefaultName" id="apidoc.element.tcomb.union.getDefaultName">
        function <span class="apidocSignatureSpan">tcomb.union.</span>getDefaultName
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultName(types) {
  return types.map(getTypeName).join(' | ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>